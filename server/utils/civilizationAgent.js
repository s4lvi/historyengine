// civilizationAgent.js

class CivilizationAgent {
  constructor(id, startingLocation) {
    this.id = id;
    // Store territory and discovered regions as sets of coordinate strings
    this.territory = new Set([`${startingLocation.x},${startingLocation.y}`]);
    this.knownWorld = new Set([`${startingLocation.x},${startingLocation.y}`]);

    // Core state parameters
    this.population = 100;
    this.resources = {
      food: 100,
      materials: 50,
      wealth: 0,
    };

    // Cultural and historical data
    this.traditions = new Map(); // tradition_id -> { origin, currentForm, importance, age }
    this.history = [];
    this.lastAction = null;
  }

  /**
   * Gathers all relevant state data into one context object.
   * This context will be fed to the LLM so it can make informed decisions.
   */
  gatherContext(mapData) {
    return {
      id: this.id,
      population: this.population,
      resources: this.resources,
      territorySize: this.territory.size,
      knownWorldSize: this.knownWorld.size,
      traditions: Array.from(this.traditions.values()),
      lastAction: this.lastAction,
      history: this.history,
      adjacentRegions: this.getAdjacentRegions(mapData),
    };
  }

  /**
   * Asks the LLM for the next strategic action.
   * The LLM is provided with a JSON-formatted context that describes
   * the current state of the civilization.
   */
  async decideNextAction(mapData, llm) {
    const context = this.gatherContext(mapData);

    // Build a prompt that explains what you expect
    const prompt = `
You are an expert advisor for a civilization simulation.
The current state of the civilization is provided as JSON below.
Based on this data, decide what the civilizationâ€™s next strategic action should be.
Return your answer in JSON format with the following keys:
  - "action": a short identifier for the action (e.g., "EXPLORE", "EXPAND", "GATHER_RESOURCES", "WAIT")
  - "parameters": an object with any additional details needed (for example, coordinates to explore or expand into)
  
Civilization State:
${JSON.stringify(context, null, 2)}

Your decision:
    `;

    // Generate the LLM response (assumes your llm.generateResponse returns a string)
    const response = await llm.generateResponse(prompt);
    let action;
    try {
      action = JSON.parse(response);
    } catch (e) {
      console.error("Error parsing LLM response:", e);
      // Fallback action if parsing fails
      action = { action: "WAIT", parameters: {} };
    }
    this.lastAction = action;
    return action;
  }

  /**
   * Applies the action generated by the LLM.
   * This method interprets the action and updates the simulation state accordingly.
   */
  applyAction(action, mapData) {
    switch (action.action) {
      case "EXPLORE": {
        const { x, y } = action.parameters;
        const key = `${x},${y}`;
        if (!this.knownWorld.has(key)) {
          this.knownWorld.add(key);
          this.history.push(`Explored region at (${x}, ${y})`);
        }
        break;
      }
      case "EXPAND": {
        const { x, y } = action.parameters;
        if (this.canExpand(x, y, mapData)) {
          this.territory.add(`${x},${y}`);
          this.history.push(`Expanded territory to (${x}, ${y})`);
        } else {
          this.history.push(
            `Attempted to expand to (${x}, ${y}) but it was not viable.`
          );
        }
        break;
      }
      case "GATHER_RESOURCES": {
        // A simple example of resource gathering.
        // In a more LLM-driven simulation, you might also query the LLM to determine yield details.
        const { x, y } = action.parameters;
        const region = mapData[y][x];
        const yieldData = this.calculateResourceYield(region);
        // Update resources based on gathered yield
        for (let key in yieldData) {
          this.resources[key] += yieldData[key];
        }
        this.history.push(
          `Gathered resources at (${x}, ${y}): ${JSON.stringify(yieldData)}`
        );
        break;
      }
      case "WAIT":
      default:
        this.history.push("Chose to wait and maintain the current state.");
        break;
    }
  }

  /**
   * Instead of using hard-coded rules for resource yield,
   * you can keep this as a simple baseline calculation or further defer to the LLM.
   */
  calculateResourceYield(region) {
    const yieldData = { food: 0, materials: 0, wealth: 0 };
    // Basic yields based on biome
    switch (region.biome) {
      case "GRASSLAND":
        yieldData.food += 3;
        break;
      case "FOREST":
        yieldData.food += 1;
        yieldData.materials += 2;
        break;
      case "RIVER":
        yieldData.food += 2;
        yieldData.wealth += 1;
        break;
      // Additional biomes can be added as needed
    }
    // Additional yields from region-specific resources
    if (region.resources) {
      region.resources.forEach((resource) => {
        switch (resource) {
          case "fertile soil":
            yieldData.food += 2;
            break;
          case "timber":
            yieldData.materials += 2;
            break;
          case "precious metals":
            yieldData.wealth += 3;
            break;
        }
      });
    }
    return yieldData;
  }

  /**
   * Determines if a new coordinate is viable for expansion.
   * Here you can perform a minimal check before allowing the LLM's decision to proceed.
   */
  canExpand(x, y, mapData) {
    // Check if (x, y) is adjacent to existing territory
    const isAdjacent = [...this.territory].some((coord) => {
      const [cx, cy] = coord.split(",").map(Number);
      return Math.abs(cx - x) <= 1 && Math.abs(cy - y) <= 1;
    });
    if (!isAdjacent) return false;

    // Check map boundaries and basic terrain viability
    if (y < 0 || y >= mapData.length || x < 0 || x >= mapData[0].length)
      return false;
    const region = mapData[y][x];
    return region.biome !== "OCEAN" && region.elevation < 0.8;
  }

  /**
   * Returns a list of regions adjacent to the current territory.
   * This data helps the LLM understand the surrounding environment.
   */
  getAdjacentRegions(mapData) {
    const adjacentCoords = new Set();
    this.territory.forEach((coord) => {
      const [x, y] = coord.split(",").map(Number);
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          const newX = x + dx;
          const newY = y + dy;
          if (
            newX >= 0 &&
            newY >= 0 &&
            newY < mapData.length &&
            newX < mapData[0].length
          ) {
            adjacentCoords.add(`${newX},${newY}`);
          }
        }
      }
    });
    return Array.from(adjacentCoords).map((coord) => {
      const [x, y] = coord.split(",").map(Number);
      return { x, y, ...mapData[y][x] };
    });
  }
}

export default CivilizationAgent;
